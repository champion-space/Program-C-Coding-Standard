# C语言编码标准

## 1.介绍

### 1.1目的

```c
减少代码错误，提高软件质量。
```

### 1.2范围

```c
使用C语言编写公司所有产品软件。
```

### 1.3文档概述

```c
C编码标准主要来自于JSF AC c++编码规则，并定义了软件复杂度阈值，一些自定义的编码规则
```

## 2.编码标准

### 2.1. JSF AV C++编码规则

#### 2.1.1代码大小和复杂性

```c
1.任何一个函数(或方法)将包含不超过200个逻辑源代码行代码(l - sloc)。
2.所有函数的圈复杂度必须小于等于20。
```

#### 2.1.2环境

```c
9.只使用在c++基本源字符集中指定的字符。这个集合包括96个字符:空格字符。控制字符表示水平制表符。垂直制表格式馈送。和newline，以及以下91个图形字符:
	a b c d e f g h i j k l m n o p q r s t u v w x y z
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
0 1 2 3 4 5 6 7 8 9
_ { } [ ] # ( ) < > % : ; . ? * + -
/ ^ & | ~ ! = , \ " ’
        
11.不使用三角符号。三字符序列是三个字符序列，被对应的单个字符替换，如下所示:
Alternative Primary 
    ??= 	#
	??/ 	\
	??' 	^
    ??( 	[
	??) 	]
	??! 	|
     ??< 	{
	??> 	}
	??-		~
12.以下图表将不会被使用:
  Alternative Primary  
       <% 	{
	   %> 	}
	   <: 	[
       :> 	]
	   %: 	#
	 %:%: 	##
 13.不会使用多字节字符和宽字符串字面值。
 14.字面后缀应使用大写字母而不是小写字母。例子:
       const int64 fs_frame_rate = 64l; // Wrong! Looks too much like 641
       const int64 fs_frame_rate = 64L; // Okay
 15.应规定运行时检查(防御性编程)。
       注:
       用于SEAL 1/2应用。防御性编程检查是必需的。防御性编程是指评估潜在的故障模式(由于硬件故障和/或软件错误)并针对这些故障模式提供安全保障的做法。对于SEAl 1/2软件。系统安全需要定义所有可能的软件。危险(软件可能导致系统功能丧失的情况)。如果从系统级别确定风险缓解将在软件中进行，则必须导出软件需求(从已识别的软件风险中)来定义适当的风险缓解。Durina编码和随后的代码检查，必须对代码进行评估，以确保减少危害要求所暗示的防御性编程技术已经实现并符合要求。使用防御性编程技术的例子包括(但不限于)管理：
       算术错误-溢出、下溢、除以零等(参见AV规则203)
       指针算术错误——动态计算的指针引用了不合理的内存位置。(见也AV规则215）
       数组边界错误——数组索引不在数组的边界内。(请参见AV规则97范围错误-传递给函数的无效参数(例如，向sqrt()函数传递一个负值)。
 注意，并非所有情况都需要显式检查，但可以使用其他形式的分析来达到相同的目的。考虑。为例。注意，边界错误是不可能通过构造来实现的。因此，无需显式检查就可以管理数组访问边界错误
                            
 const uint32 n = a.size();
for (uint32 i=0 ; i<n ; ++i)
{
    a[i] = i;
}
```

#### 2.1.3预处理指令

```c
29.#define预处理器指令不能用于创建内联宏。内联函数改为应使用。
例子:
#define max (a,b) ((a > b) ? a : b)	// Wrong: 宏
inline int32 maxf (int32 a, int32 b) // 正确: 内联函数
{
	return (a > b) ? a : b;
}
y = max (++p,q); // Wrong: ++p 计算两次
y=maxf (++p,q)// Correct: ++p 一次计算和类型
    		//检查执行。
31.define预处理器指令只能作为防止同一个头文件被多个包含的技术的一部分。
32.#include预处理器指令只用于include header (.h) files。注:
	该规则的例外涉及到模板类和函数定义，它们可以被划分为单独的头文件和实现文件。在这种情况下，实现文件可能作为头文件的一部分包含。注意，实现文件在逻辑上是头文件的一部分，不能像下面所示的那样单独兼容。
例子:
	File A.h:
--------------------------------
	#ifndef A_H
	#define A_H
	const int32_t g_temp = TEMP;
	#include <A.c>
	#endif
```

#### 2.1.4头文件

```c
35.头文件将包含一种机制，防止自己被多个包含。
39.头文件(*.h)将不包含非const变量定义或函数定义
    例子：
    const int32_t g_temp = TEMP1; // Good
		 int32_t g_temp2 = TEMP2; // 不兼容
```

#### 2.1.5风格

```c
40.每个实现文件都应该包括头文件，头文件唯一地定义了所使用的内联函数、类型和模板。
42.每个表达式语句将在单独的一行中。
    例子：
    x = 7; y=3;	//不正确:多个表达式语句在同一行。
    a[i] = j[k]; i++; j++;	//不正确:多个表达式语句在同一行。
43.应避免使用标签	tabs
44.所有缩进将至少是两个空格，并且在同一源文件中保持一致。
    例子：
    int exec_add(int32_t first, int32_t second)
	{
		int temp = first + second; //2 indentations
			return temp; //4 indentations
	}
46.用户指定的标识符(内部和外部)将不依赖于超过64个字符的重要性。
47.标识符不会以下划线字符'_'开始。
    例子：
    int32_t g_temp = TEMP;
	int32_t _g_temp2 = TEMP2; // 不兼容
48.标识符不会因以下因素而不同:
	只是一种混合情况
     下划线字符的存在/缺失
     字母“O”的互换;有数字O或字母D
     字母l与数字“1”或字母“1”的互换
     字母S和数字5的互换
     字母“Z”与数字“2”的互换
     字母“n”与数字“h”的互换
 51.函数名和变量名中包含的所有字母将完全由小写字母组成。
 53.头文件的扩展名为“.h”。
  53.1以下字符序列不能出现在头文件名称中:'，\，/*，ll，或"
      例子：
      #include <foo /* comment */ .h> // Bad: “/*” 禁止
	 #include <foo’s .h> // Bad: “’” 禁止
	 #include <dir1\dir2\foo.h> // Bad: “\” 禁止
	 #include <dir1/dir2/foo.h> // Good: 使用相对路径
 58.当声明和定义具有两个以上形参的函数时，前导圆括号和第一个形参将与函数名写在同一行。每个附加的参数将被写在单独的一行中(在最后一个参数后面直接加上右括号)
      例子：
      int32 max (int32 a, int32 b) // 正确:可能会出现两个参数
		{ //同样的。秩序很容易理解。
			…
		}

	  msg1_in (uint16 msg_ID, float32 rate_IO, uint32 msg_size, uint16 rcv_max_instances)
		{
			…
		}//正确的形式。

	  msg1_in ( uint16 msg_ID, //消息标签的唯一标识符
				float32 rate_IO, //需要的消息分发速率
				uint32 msg_size, //以字节为单位的消息大小
				uint16 rcv_max_instances) //这个的最大实例数
//在处理帧中需要的消息
		{
			…
		}
59.if, else if, else, while, do…While或for语句应该总是用大括号括起来，即使大括号构成一个空块。
    例子：
    if (flag == 1)
	{
        success ();
	}
	else //错误用法:log_error()是后来添加的  
		clean_up_resources(); //但不是块的一部分(即使它处于适当的缩进级别)
		log_error(); 
	while (f(x)); //错误:"；"很难看到。
	while (f(x)) //错误:"；"很难看到。
		;
	while (f(x)) // 正确的
	{
	}
60.括号("{}")包含一个块将被放置在同一列中，直接在前后分开的行上。
    例子：
    if (var_name == true)
	{ // 兼容
	}
	else { // 不兼容
	}
61.括号("{}")包含一个块，除了注释外，该行没有其他内容
62.解引用操作符' * '和地址操作符' & '将直接与类型说明符连接。
    例子：
    int32* p; // 正确
	int32 *p; //错误
	int32* p, q; //可能的错误。 然而，该声明不能出现在AV规则152要求的每个声明风格的一个名称下。
63.空格不会在'或'->'前后使用，也不会在一元操作符和操作数之间使用
```

#### 2.1.6功能

```c
107.函数应始终在文件作用域声明。
110.参数超过7个的函数将不会被使用。
111.函数不能返回指向非静态局部对象的指针或引用。
    例子：
    下面的示例说明了函数返回值可以掩盖资源所有权的几种方法  
因此存在资源泄漏的风险。 注意，在以下示例中，new不需要从堆中分配内存，但可能会在class上超载。
   X& f (float32 a)
	{
		return *new x(a); //容易出错。 调用者必须记住执行删除操作。
	} //the delete
	X& ref = f(1); // f（1)的调用者必须负责删除内存。
	… // the memory.
	delete &ref //每次调用f0都必须调用delete。
	…
	X& x = f(1)*f(2)*f(3)*f(4);//内存泄漏:对于临时对象不调用删除。
113.函数只有一个退出点。
114.返回值函数的所有出口点都必须通过return语句。
116.如果对形参的更改不应反映在调用函数中，则应通过值传递小的具体类型实参(大小为两个或三个字)。
119.函数不能直接或间接调用自己(即不允许递归)
121.只有包含1或2条语句的函数才应该被认为是内联函数的候选函数。
122.普通访问函数和变异函数应该内联。
    例子：
    int32 g_limit = 0;
	int32 get_limit (void) // 要内联的样例访问器
	{
		return g_limit;
	}
	void set_limit (int32 limit_parm)//要内联的样本变量
	{
		g_limit = limit_parm;
	}
```

#### 2.1.7注释

```c
127.不使用的代码(注释掉)应被删除
128.在文件之外记录动作或来源(如表格、图表、段落等)的注释  
文件是不允许的。只有当文件本身需要更改时，文件中的注释才需要更改。 请注意,这规则不排除文件中可能包含的实体的有效假设的文档 
129.头文件中的注释应该描述被记录函数的外部可见行为。
130.每一行可执行代码的目的都应该用注释来解释，尽管一条注释可能描述不止一行代码。
131.应该避免在注释中说明代码中更好说明的内容(即不要简单地重复代码中的内容)。
    例子：下面的例子说明了一个不必要的注释。
    a = b+c;//不好的：b加c，把结果放在a上。
132.每个变量声明、类型定义、枚举值和结构成员都将被注释。使用"//"创建成员注释。
    例子：
    typedef struct color_t
	{
		int red; //the red value
				//取值范围 0~255
		int green; //the green value
	} color_t;
133.每个源文件都会有一个介绍性注释，提供关于文件名、内容和任何程序所需信息(例如法律声明、版权信息等)的信息。
    格式：
    /*====================================================================
*
* 					[标题]
*
* 描述
* 		[文件描述]
*
*
*
* 					版权信息
*
* 版权 (c) 2019-2029 塔上半导体(上海) 有限公司.
* 版权所有.
* 塔上 机密和所有权
*==================================================================*/
/*===================================================================
*
* 				为文件编辑历史记录
*
* 本节包含描述对模块所做更改的注释。注意，更改是以倒叙的方式列出的指令
*
*
* 什么时候 谁 做什么, 在哪, 为什么
* ---------- ---------------- ----------------------------------------------
* YYYY-MM-DD [开发者] [变化描述]
*==================================================================*/
134.函数的假设(限制)应该记录在函数的序言中。
    格式：
    /**
	* [功能描述]
	* @作者 [作者姓名]
	* @日期和时间 [日期和时间]
	* @参数 [param1] [参数描述]
	* @param [param2] [param2 description]
	* @param [paramX] [paramX description]
	* @返回值 [返回值描述]
	*/
    例子：
    /**
	* 读取dhcp客户端列表
	* @作者 pasding
	* @日期 2019-09-17T11:39:56+0800
	* @参数 iftype  网口类型，enum NW_IF_TYPE
	* @param ifnumber 接口数量标识符
	* @param clients dhcp客户端列表
	* @param count 客户端列表的最大计数作为输入，实际计数					作为输出
	* @return 成功返回0, 失败返回其它
	*/
    int ts_api_nw_read_dhcp_client_list(int iftype, int ifnumber, struct dhcp_client_t * clients, int * count);
```

#### 2.1.8声明和定义

```c
135.内部作用域中的标识符不能与外部作用域中的标识符使用相同的名称，因此要隐藏该标识符。
    例子：
    int32 sum = 0;
	{
    	int32 sum = 0; // 坏的: 在外部隐藏sum
		…
		sum = f (x);
	}
137.在文件作用域中的所有声明都应该尽可能是静态的
    说明：
    默认情况下，文件作用域的声明是外部的。因此，如果两个文件都在文件作用域中声明了一个同名的标识符，连接器要么会给出错误，要么会给出相同的变量，这可能不是程序员想要的。如果其中一个变量在某个库中，这也是正确的。静态存储类说明符的使用将确保标识符仅对声明它们的文件可见。
如果一个变量只供同一文件中的函数使用，则使用static。类似地，如果一个函数只从其他地方调用，使用static。
    通常，那些声明出现在头文件(.h)中的函数是为了从其他文件调用，因此不应该用static关键字指定。相反，那些声明出现在实现体(.cpp)文件中的函数永远不应该从其他文件调用，因此应该始终使用static关键字声明。
138.标识符在同一翻译单元中不能同时具有内部和外部链接。
    例子：
    {
		static int32 i=1; // line 1
		{ // 坏的:带有外部链接的i隐藏了i
			// 与内部联系.
			extern int32 i; // line 2
			…
			a[i] = 10; // line 3: 混乱: which i?
		}
}
139.外部对象不会在多个文件中声明
    例子1：两个文件声明相同的变量。这种样式可能会导致错误，因为a可能在许多不同的文件中声明。这些文件中的任何一个更改都会影响到其他所有文件，而且很难精确定位
    // In File_1.cpp
		int32 a = 3;
	// In File_2.cpp
		extern int32 a;
	例子2：在这里，a在头文件中声明。所有其他需要访问的文件只需包含头文件。这样就保证了一致性。
        // In File_1.h
			extern int32 a;
		// In File_1.cpp
			#include <File_1.h>
			int32 a = 3;
		// In File_2.cpp
			#include <File_1.h>
141.类、结构或枚举不会在其类型的定义中声明。
    例子：在其类型的定义中声明枚举可能会导致可读性问题和未命名的数据类型，如下所示
    enum // 不要这样做:创建一个未命名的数据类型。
	{
		up,
		down
	} direction;
enum i { in, out } i; // 不要这样做:难以阅读
enum XYZ_direction
{
	up,
	down
};
```

#### 2.1.9初始化

```c
142.所有变量在使用前都必须初始化
143.变量只有在可以用有意义的值初始化时才会被引入
    例子：
    void fun_1() // 不好的实现
	{
		int32 i; // 坏的: I被提前声明(目的是在for中使用I									循环）
		int32 max=0; // 坏的: 用虚拟值初始化的Max。
		… // 坏的：i和max在这个代码范围内没有意义
         max = f(x);
			for (i=0 ; i<max ; ++i)
			{
				…
			}
		…. // 坏的:i不应该在这里使用，但无论如何都可以使用
	}


void fun_1() // 好的实现
{
	….
int32 max = f(x); // 直到有意义的值时才引入Max
				// 可用
for (int32 i=0 ; i<max ; ++i) // 好:i直到需要时才被声明或初始化
	{ // Good: I只在for循环的作用域内已知
		…
	}
}
144.花括号应使用指示并匹配数组和结构的非零初始化中的结构。
    例子：
    int32 a[2][2] = { {0,1} ,{2,3} };
145.在枚举列表中，' = '构造不能用于显式初始化除第一个成员外的其他成员，除非显式初始化了所有项
    例子1：
    //使用编译器分配的枚举值的合法枚举列表
    //off=0, green=1, yellow=2, red=3
    
    enum Signal_light_states_type
	{
		off,
		green,
		yellow,
		red
	};
	例子2：
	//合法枚举，为列表中的第一项赋值。
        enum Channel_assigned_type
		{
			channel_unassigned = -1,
			channel_a,
			channel_b,
        	 channel_c
		};
	例子3：
     //控制掩码枚举列表。所有项目明确
     //初始化
        
        enum FSM_a_to_d_control_enum_type
		{
			start_conversion = 0x01,
			stop_conversion = 0x02,
			start_list = 0x04,
			end_list = 0x08,
			reserved_3_bit = 0x70,
			reset_device = 0x80
		};
	例子4：
     //合法:用于索引数组的枚举的标准约定。
        enum Color {
			red,
			orange,
			yellow,
			green,
			blue,
			indigo,
			violet,
			Color_begin = red,
			Color_end = violet,
			Color_NOE //数组中元素的个数
			};
147.浮点数的底层位表示形式不能被程序员以任何方式使用。
    注释：
    操纵浮点数的底层位表示很容易出错，因为不同的编译器和平台的表示可能不同。但是，可以使用特定的内置操作符和函数来提取浮点值的尾数和指数。
148.枚举类型应使用而不是整数类型(和常量)，以便从有限的一系列选择中进行选择。
```

#### 2.1.11常量

```c
149.不能使用八进制常量(非零)。
150.十六进制常量将全部使用大写字母表示。
151.代码中的数值将不会被使用;取而代之的是符号值。
    151.1字符串字面值不能被修改。
    例子：因为字符串字面值是常量，所以它们只能被赋值给常量指针，如下所示:
char* c1 = “Hello”; //坏:赋给非const
char c2[] = “Hello”; //坏:赋给非const
char c3[6] = “Hello”; //坏:赋给非const
c1[3] = ‘a’; //未定义(但编译)
const char* c1 = “Hello”; // Good
const char c2[] = “Hello”; // Good
const char c3[6] = “Hello”; // Good
c1[3] = ‘a’; // 编译错误
```

#### 2.1.12变量

```c
152.不允许在同一行上声明多个变量。
    例子：
    int32* p, q; //可能错误。
	int32 first button_on_top_of_the_left_box, i;
				//坏的:容易被忽视
```

#### 2.1.13联合体和bit字段

```c
154.bit必须只有明确的的无符号整数或枚举类型。
156.一个结构(或类)的所有成员都应该被命名，并且只能通过他们的名字访问。
```

#### 2.1.14操作符

```c
157.操作符&&或||的右侧操作数不得包含副作用。
    例子：当使用短路操作器时要小心。例如，如果下面代码中的逻辑表达式的计算结果为错误，则变量x将不会递增。这可能会有问题，因为后面的语句可能会假设x已经递增。
    if ( logical_expression && ++x) //坏:右边不计算，如果逻辑
// 表达式错误.
		…
		f(x); //错误:假设x总是递增。
		…
 158.如果逻辑的&&或||的操作数包含二进制操作符，则该操作数必须用括号括起来。
   例子：
valid (p) && add(p) //不需要括号
x.flag && y.flag //不需要括号
a[i] || b[j] //不需要括号
(x < max ) && (x > min) //需要括号
(a || b) && (c || d) // /需要括号
 160.赋值表达式应使用仅作为表达式语句中的表达式。
 例子：
x = y; //好的:意图将y赋值给x，然后检查x是否为非零被显式声												明。
if (x != 0) 
{
	foo ();
}

if ( ( x = y) != 0 ) //不好:不像可能的那样可读。
{ 				//赋值应该在if语句之前执行
	foo ();
}
if (x = y) //坏的:意图很模糊:一个代码审查者很容易
			//认为是“==”而不是“=”。
{ 
	foo ();
}
for (i=0 ; i<max ; ++i) //好的：在" for "语句的表达式语								句中赋值
{
	…
}
162.有符号值和无符号值不能在算术或比较操作中混合使用。
164.移位运算符的右操作数必须在左操作数的位宽(包括位宽)的0到1之间。 
    164.1右移操作符的左操作数不能为负数。
165.一元减运算符不能应用于无符号表达式。
166.sizeof操作符不会用于包含副作用的表达式。
168.不能使用逗号操作符。
```

#### 2.1.15指针和引用

```c
170.不得使用超过2级的指针。
171.关系操作符不能应用于指针类型，除非两个操作数的类型相同，并且指向:
	•同一个对象，
	•相同的功能，
	•同一对象的成员，或
	•同一个数组的元素(包括同一个数组的结尾)。
 173.具有自动存储功能的对象的地址不应分配给在该对象停止存在后仍然存在的对象。
 174.空指针不能被取消引用。
 176.在声明函数指针时，将使用typedef来简化程序语法。
```

#### 2.1.16流控制标准

```c
186.不存在不可访问的代码。
187.所有非空语句都可能有副作用。
    例子1：
    潜在的副作用
    if (flag) // 只有当标志为真时才有作用。
	{
		foo();
	}
	例子2：
     下面的表达式没有副作用
     3 + 4; // Bad: 声明没有任何副作用
	例子3：
      下面的表达方式有副作用
      x = 3 + 4; // 语句有一个副作用:x被设为7。
	  y = x++; //语句两个副作用:y被设为x, x递增。
188.标签将不会被使用，除非在switch语句中。
189.不能使用goto语句。
192.所有if、else if构造都将包含一个最后的 else子句或一个说明为什么不需要 else子句的注释。
    例子1：因为没有else if，所以不需要 else子句。
    if (a < b)
	{
		foo();
	}
	例子2：如果前面的条件都不满足，则需要最后的else条款。
     if (a < b)
	{
		…
	}
	else if (b < c)
	{
		…
	}
	else if (c < d)
	{
	}
	else //需要最后的else子句
	{
		handle_error();
	}
	例子3：不需要 else子句，因为所有可能的条件都被处理了。因此，本文对这一情况进行了说明。
     if (status == error1)
	{
		handle_error1();
	}
	else if (status == error2)
	{
		handle_error2()
	}
	else if (status == error3)
	{
    	handle_error3()
	} //不需要 else:所有可能的错误都被解释了。
193.switch语句中的每个非空case子句都应以break语句结束。
    例子：
    switch (value)
	{
		case red : //为空，因为应该调用primary_color()
		case green : //为空，因为应该调primary_color()
		case blue :
			primary_color (value);
			break; //必须中断以结束处理
		case cyan :
		case magenta :
		case yellow :
			secondary_color (value);
			break; ：//必须中断以结束二级处理
		case black :
			black (value);
			break;
		case white :
			white (value);
			break;
	}
194.所有不打算测试每个枚举值的switch语句都应该包含一个最终默认子句。
195.switch表达式不会表示布尔值。
196.每个switch语句至少有两种情况和一个潜在的默认值
197.浮点变量不能用作循环计数器。
198. for循环中的初始化表达式除了初始化单个for循环参数的值外，不执行任何操作。
    例子：
    for (int32 i = 0 ; i < 100 ; ++i) // Good
	{
		…
	}
199. for循环中的自增表达式除了将单个循环参数更改为该循环的下一个值外，不执行任何操作。
200. for循环中不会使用空的初始化或自增表达式;取而代之的是一个while循环。
201.在for循环中用于迭代计数的数值变量不能在循环体中修改。
```

#### 2.1.17表达式

```c
202.浮点数变量不应进行精确的相等或不相等测试。
203.表达式的评估不应导致溢流/下流。
204.有副作用的单一表达式只能在下列情况下使用:
	•  自己本身
	•  赋值的右边
	•  一个条件
	•  在函数调用中唯一有副作用的参数表达式
	•  循环条件
	•  选择条件
	•  单一的链接操作
    例子1：自己本身
     ++i; // Good
	for (int32 i=0 ; i<max ; ++i) // Good: 包括表达式的									部分声明
	i++ - ++j; //不好: 操作本身没有副作用
	例子2：赋值的右边
      y = f(x); // Good
	  y = ++x; // Good: 逻辑上和y=f(x)相同
	  y = (-b + sqrt(b*b -4*a*c))/(2*a); // Good: 									Sqrt()没有副作用
	  y = f(x) + 1; // Good: 副作用可能发生与常数
	  y = g(x) + h(z); //坏的:有副作用的操作不会自行发生
						// 关于分配的RHS
	  k = i++ - ++j; // Bad: 同上
	  y = f(x) + z; // Bad: 同上
	例子3：一个条件
       if (x.f(y)) // Good
	   if (int x = f(y)) // Good: 这种形式通常用于动态类											型转换
		// if (D* pd = dynamic_cast<D*> (pb)) {…}
	  if (++p == NULL) // Good: 副作用可能发生与常数
      if (i++ - --j) // Bad:有副作用的操作不会自行发生
			// 在一个条件中
     例子4：在函数调用中唯一有副作用的参数表达式
       f(g(z)); // Good
	   f(g(z),h(w)); // Bad: 两个有副作用的参数表达式
	   f(++i,++j); // Bad: 同上
	   f(g(z), 3); // Good: 副作用可能发生与常数
	例子5：循环条件
         while (f(x)) // Good
		while(--x) // Good
		while((c=*p++) != -1) // Bad:有副作用的操作不会								自行发生在循环条件中
    例子6：选择条件
        switch (f(x)) // Good
		switch (c = *p++) // Bad: 操作本身没有作用在选								择条件中
    例子7：单一的链接操作
        x.f().g().h(); // Good
		a + b * c; // Good: 重载操作符+()和操作符*()
		cout << x << y; // Good
	204.1在标准允许的任何注释顺序下，表达式的值应是相同的。
        例子：由于运算符和子表达式的求值顺序是未指定的，表达式必须按照标准允许的任何顺序来编写，以产生相同的值。
        i = v[i++]; // Bad: 未指明的行为
		i = ++i + 1; // Bad: 未指明的行为
		p->mem_func(*p++); // Bad:未指明的行为
205.除非直接与硬件接口，否则不应使用volatile关键字。
```

### 2.2规则

#### 2.2.1软件复杂性

```
N.  			定义  					临界值
SC01 		行数超过临界。					  10000
SC02 		注释密度低于临界。  				    20
SC04		调用函数个数超过临界。  				5
SC05 		被调用函数个数超过临界 			   20
SC07 		功能参数个数超过临界 					7
SC12 		语句数超过临界  					200
SC13 		goto语句数超过临界  				  0
SC14 		调用嵌套深度超过临界  				6
SC15 		静态路径数超过临界  				1000
SC16 		返回语句数量超过临界  				1
SC17 		圈复杂度超过临界  					20
SC18		语言范围超出阈值  					400
```

### 2.3自定义

#### 2.3.1结构体

```c
4.1所有的structs标签必须是小写字母并且以“_t”结尾。
    例子：
    typedef enum color_t
	{
		int32_t red;
		int32_t green,
		int32_t blue
	} color_t;
4.2所有结构体类型必须是小写字母，并且以“_t”结尾。
    例子：
    typedef enum color_t
	{
		int32_t red;
    	int32_t green,
		int32_t blue
	} color_t;
```

#### 2.3.2枚举

```c
6.1所有枚举标记必须是小写字母，并以“_e”结尾。
    例子：
    typedef enum color_e
	{
		RED,
		GREEN,
		BLUE
	} color_e;
6.2所有枚举类型必须为小写字母，并以“_e”结尾。
    例子：
    typedef enum color_e
	{
		RED,
		GREEN,
		BLUE
	} color_e;
6.3所有枚举常量必须是大写字母。
```

#### 2.3.3常量

```c
8.1所有全局常量必须是大写字母。
8.2所有全局静态常量必须是大写字母
```

#### 2.3.4变量

```c
8.1所有全局变量必须小写，并且以g_开头。
    例子：
    int32 g_temp = 0;
```

#### 2.3.5风格

```c
20.1源代码行长度不能超过80。
```

## 3.附录

### A.词汇表

```
缩写						定义
JSF						JOINT STRIKE FIGHTER
AV  					AIR VEHICLE
MISRA  					Motor Industry Software 								Reliability Association
```

### B.面向多空间的Tashang编码标准XML

